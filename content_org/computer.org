#+TITLE: Computer Science
#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: computer
#+FILETAGS:computer
#+HUGO: more
#+SEQ_TODO: TODO NEXT DONE
#+HUGO_AUTO_SET_LASTMOD: t
#+hugo_front_matter_key_replace: description>summary
#+SETUPFILE: ~/.spacemacs.d/org-templates/math.org
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="../static/css/worg.css"  />

* Computer
** TODO dive into the tensorflow
:PROPERTIES:
:EXPORT_FILE_NAME: dive-into-the-tensorflow
:EXPORT_DATE: <2018-05-27 Sun 21:07>
:EXPORT_DESCRIPTION: my understanding and analysis of the tensorflow
:END:
:LOGBOOK:
CLOCK: [2018-05-27 Sun 21:07]--[2018-05-27 Sun 21:42] =>  0:35
:END:

My understanding and analysis of the [[https://www.tensorflow.org/][tensorflow]] platform.

* python
[2018-05-27 Sun 20:50]
** DONE learn python the hard way                  :python:
CLOSED: [2018-05-27 Sun 20:43]
:PROPERTIES:
:EXPORT_FILE_NAME: learn-python-the-hard-way
:EXPORT_DATE: <2018-05-04 Fri 21:46>
:EXPORT_DESCRIPTION: As a language of the AI era, python plas an important role in interacting with the low level API to fasten the project.
:END:
:LOGBOOK:
- CLOSING NOTE [2018-05-27 Sun 20:43] \\
  done
CLOCK: [2018-05-04 Fri 22:09]--[2018-05-04 Fri 23:34] =>  1:25
CLOCK: [2018-05-04 Fri 21:57]--[2018-05-04 Fri 21:58] =>  0:01
CLOCK: [2018-05-04 Fri 21:51]--[2018-05-04 Fri 21:57] =>  0:06
CLOCK: [2018-05-04 Fri 21:46]--[2018-05-04 Fri 21:50] =>  0:04
:END:

For a long time, I have been planning to learn Python. However, because I never
use Python in my work, the plan was delayed again and again. Today, it is
raining cats and dogs outside. Why not do something I have planned long time ago
in this perfect mode? So I picked up the book /Learning Python the Hard Way/ by
Zed Shaw. During the learning, I use Emacs as my Editor, running the programming
on my old Thinkpad with Ubuntu 16.04 and Python3.5. I am going to learn Python
in the hard way. However, I believe it will be the clever and efficient way.
*** a small surprise in ex4.py
Everything goes fine until I am doing exercise 4. The python code is:
    #+begin_src python -n :results output :exports both
cars = 100
space_in_a_car = 4
drivers = 30
passengers = 90
cars_not_driven = cars - drivers
cars_driven = drivers
carpool_capacity = cars_driven * space_in_a_car
average_passengers_per_car = passengers / cars_driven

print("There are",cars,"cars available.")
print("There are only",drivers,"drivers avaiable.")
print("There will be", cars_not_driven,"empty cars today.")
print("We can transport",carpool_capacity,"people today.")
print("We have",passengers,"to carpool today.")
print("We need to put ablout",average_passengers_per_car,"in each car")
    #+end_src

#+RESULTS:
: There are 100 cars available.
: There are only 30 drivers avaiable.
: There will be 70 empty cars today.
: We can transport 120 people today.
: We have 90 to carpool today.
: We need to put ablout 3.0 in each car


and the result is shown belowing the code.

Notice that in the source, the first line concerning print is:
    #+begin_src python
print("There are",cars,"cars available.")
    #+end_src
instead of
    #+begin_src python
print("There are ",cars," cars available.")
    #+end_src
Notice the difference? the whitespace. In Python, the whitespace is inserted
around the results automatically which is kind of a surprise for a programmer
familiar with =C/C++= .
*** imcompatiblility  between python 3.5 and 3.6
[2018-05-05 Sat 09:33]

I have python3.5 installed on my Ubuntu 16.04 hoping it will help me go through
the book /Learning Python the Hard Way/ . However, when it comes to ex5.py, the
dream is waken up.

    #+begin_src python -n
my_name = 'Zed A. Shaw'
my_age = 35
my_height = 74
my_weight = 180
my_eyes = 'Blue'
my_teeth = 'White'
my_hair = 'Brown'

print(f"Let's talk about {my_name}.")
print(f"He's {my_height} inches tall.")
print(f"He's {my_weight} pounds heavy.")
print("Actually that's not too heavy.")
print(f"He's got {my_eyes} eyes and {my_hair} hair.")
print(f"His teeth are usually {my_teeth} depending on the coffee.")

# this line is tricky, try to get it exact right
total = my_age + my_height + my_weight
print(f"If I add {my_age}, {my_height}, and {my_weight} I get {total}.")
    #+end_src

When I execute =python3.5 ex5.py= in terminal. SyntaxError is triggered and it
says:
#+begin_example
  File "ex5.py", line 9
    print(f"Let's talk about {my_name}.")
                                       ^
SyntaxError: invalid syntax
#+end_example

After carefully comparison with the code in the book, I found no mistakes. So
maybe it is the interpreter that raise the error. So python 3.6 is installed.
    #+begin_src shell
sudo add-apt-repository ppa:jonathonf/python-3.6
sudo apt-get update
sudo apt-get install python3.6
    #+end_src

Then I execute =python3.6 ex5.py=, hooray, it works with output:
#+begin_example
Let's talk about Zed A. Shaw.
He's 74 inches tall.
He's 180 pounds heavy.
Actually that's not too heavy.
He's got Blue eyes and Brown hair.
His teeth are usually White depending on the coffee.
If I add 35, 74, and 180 I get 289.
#+end_example
After this, I began to worry python for its incompatibility even after python3.
Even this little =print= function shows difference, what about other features?
*** default end is enter
[2018-05-05 Sat 19:38]

In ex7.py
    #+begin_src python
print("Mary had a little lamb.")
print("Its fleece was white as {}.".format('snow'))
print("And everywhere that Mary went.")
print("."*10)

end1 = "C"
end2 = "h"
end3 = "e"
end4 = "e"
end5 = "s"
end6 = "e"
end7 = "B"
end8 = "u"
end9 = "r"
end10 = "g"
end11 = "e"
end12 = "r"
# watch end = '' at the end. try removing it to see what happens
print(end1 + end2 + end3 + end4 + end5 + end6 , end=' ')
print(end7 + end8 + end9 + end10 + end11 + end12)
    #+end_src


The output is:
#+begin_example
Mary had a little lamb.
Its fleece was white as snow.
And everywhere that Mary went.
..........
Cheese Burger
#+end_example

Notice the line:
    #+begin_src python
print(end1 + end2 + end3 + end4 + end5 + end6 , end=' ')
    #+end_src

This line change the default =end= as whitespace. By default, the =end= will be
=enter=
*** the multiline string
[2018-05-05 Sat 21:18]

There are two ways to generate multiline string. first is using the escape
sequence; second is to use three double-quotes pair. Today, I found that three
single-quotes pair is also ok. see the example below.

    #+begin_src python :results output
fat_cat ='''
I'll do a list:
\t* Cat food
\t* Fishies
\t* Catnip\n\t* Grass
'''

thin_mouse ='''
I'll do another list:
\t* mouse food
\t* Rice
\t* Catnip\n\t* Grass
'''
print(fat_cat)
print(thin_mouse)
    #+end_src

#+RESULTS:
#+begin_example

I'll do a list:
  ,* Cat food
  ,* Fishies
  ,* Catnip
  ,* Grass


I'll do another list:
  ,* mouse food
  ,* Rice
  ,* Catnip
  ,* Grass
#+end_example

also don't foget that the string can be format by prefix a =f= to be a f-string.
*** help in Ipython
[2018-05-05 Sat 22:18]

I like Ipython because of its REPL style. To get help of a function just follow
the function with a ? or ??, then hit the return.

For example, I want to read the help for the builtin function =input=
#+begin_example
In [1]: input?
Type:        builtin_function_or_method
String form: <built-in function input>
Namespace:   Python builtin
Definition:  input(prompt)
Docstring:
Read a string from standard input.  The trailing newline is stripped.

The prompt string, if given, is printed to standard output without a
trailing newline before reading input.

If the user hits EOF (*nix: Ctrl-D, Windows: Ctrl-Z+Return), raise EOFError.
On *nix systems, readline is used if available.
#+end_example

Maybe, ? and ?? will be the most frequenct symbol I use during using python.
*** call a script with more inputs
[2018-05-05 Sat 22:30]

You can call a script with more inputs using the =argv= module
    #+begin_src python
from sys import argv
# read the WYSS section for how to run this
script, first, second ,third = argv

print("The script is called:",script)
print("Your first variable is:",first)
print("Your second variable is:",second)
print("Your third variable is:",third)
    #+end_src

when save the above code as ex13.py, then call it from the shell:
#+begin_example
python3.6 ex13.py 1st 2nd 3rd
#+end_example

Then the =argv= will contains the =ex13.py= =1st= =2nd= =3rd= . The first line
of the code:
    #+begin_src python
script, first, second, third = argv
    #+end_src
unpack the =argv= . Then, =script ='ex13.py'=  =first = '1st'=  =second = '2nd'=
and so on.

Another way allowing the user to input is using the function =input= .
*** open a file
[2018-05-06 Sun 08:24]

    #+begin_src python
txt = open(filename)
    #+end_src

The =txt= is not the contents of the file. It is a file object. By this object,
you can move around and read the file. Actually, we can open the file twice and
use two different file objects pointing to the same file.


A file opject also has the following function:
#+CAPTION: functions that a file object can call
#+NAME: tab:20180506functionsatablecall
#+ATTR_HTML: :border 1 :rules all :frame border :align center
#+ATTR_LATEX: :align center
|----------------+-----------------------------------------------------------|
| name           | description                                               |
|----------------+-----------------------------------------------------------|
| close          | close the file                                            |
| read           | read the contents of the file                             |
| readline       | reads just one line of a text file                        |
| truncate       | empties the file                                          |
| write('stuff') | writes "stuff" into the file                              |
| seek(0)        | move the read/write location to the beginning of the file |
|----------------+-----------------------------------------------------------|

By default, the file is opened for reading. If you want to open a file and
writing something into it, use:
    #+begin_src python
txt = open(filename,'w')
    #+end_src

If you want to open a file, read the contents, then write something into it.
    #+begin_src python
txt = open(filename,'r+')
    #+end_src

Actually, there is another option for reading and writing =w+=, and the
difference is :
1. =r+= Open for reading and writing.  The stream is positioned at the beginning
   of the file.
2. =w+= Open for reading and writing.  The file is created if it does not exist,
   otherwise it is truncated.  The stream is positioned at the beginning of the
   file.

Notice that the =w+= option will truncate the file if it exists. Also, the =w=
option will truncate the file if exists. So the =target.truncate()= is not
necessary if you open a file with =w= or =w+= .

On =close= your file, you will find that most of the time it is ok not close it
because Cpython will do it for you. However, when you forget to close the file,
the contents aimed to be written into the file is actually stored in a buffer.
until you close the file, the contents will not be saved to the file.
*** call function recursively
[2018-05-06 Sun 12:01]

Look at the code below:
    #+begin_src python
# this one is like your scripts with argv
def print_two(*args):
    arg1,arg2,arg3 = args
    print(f"arg1: {arg1},arg2: {arg2}, arg3: {arg3}")
    print_none()
# ok, that *args is actually pointless, we can just do this
def print_two_again(arg1,arg2):
    print(f"arg1: {arg1},arg2: {arg2}")

# this just takes one argument
def print_one(arg1):
    print(f"arg1: {arg1}")

# this one takes no arguments
def print_none():
    print("I got nothin'.")
    print_two("Zhang","Chao","long")

print_two_again("Zed","Shaw")
print_one("First!")
print_none()
    #+end_src

Notice that =print_two= calls =print_none= and vice versa. This will raise the
RecursionError :
#+begin_example
RecursionError: maximum recursion depth exceeded while calling a Python object
#+end_example

I am just curious what will happen if I let two functions call each other
recursively. :)
*** the input of a function
[2018-05-06 Sun 14:33]

Input to a function is just like =argv= to a script. I found that duirng the
input of a function can also be a function:
    #+begin_src python
print("input the argument:")
cheese_and_crackers(input("arg1:"),input("arg2:"))
    #+end_src

Drill more on the =input("arg1:")= , I found that the return of =input("arg1:")=
is a str, so there must be an automatic convert from str to int for the
=cheese_and_crackers= .

    #+begin_src python
cheese_and_crackers(input("arg1:")+10,input("arg2:"))
    #+end_src

will raise a TypeError. So:
    #+begin_src python
cheese_and_crackers(int(input("arg1:"))+10,input("arg2:"))
    #+end_src

will work as I wish. Furthermore, maybe the =int= should be =float= to accept
float number.
*** variable in the for loop
[2018-05-19 Sat 19:43]

In a =for= loop, python can use a variable that isn't defined yet. This is because
that the =for= loop defines the variable and initialize it to the current
element of the loop iteration each time through.

Now, we give an example:
    #+begin_src python -n
# we can also build lists, first start with an empty one
# you have to define this variable before you use it.
elements = []

# then use the range function to do 0 to 5 counts
for i in range(4,100,16):
    # you don't have to define i before you use it.
    print(f"Adding {i} to the list.")
    # append is a function that lists understand
    elements.append(i)


i = 20
print(f"i is {i}")
# now we can print them out too
for i in elements:
    #even you define i = 6, i will be overwritten in the for statement
    print(f"Element was: {i}")

print(f"i is {i}")
    #+end_src

At first, we define an empty list =elements= , then we fill the list with
=range(3,100,16)= . After that we print the elements of the list. Notice that
even we define a variable =i=20= , the statement =for i in elements:= will
define a new variable =i= and overwrite the value of =20= . The value of the new
=i= is the value of the first element of the list. After each loop, the =i=
steps through the list.

The result is:
#+begin_example
Adding 4 to the list.
Adding 20 to the list.
Adding 36 to the list.
Adding 52 to the list.
Adding 68 to the list.
Adding 84 to the list.
i is 20
Element was: 4
Element was: 20
Element was: 36
Element was: 52
Element was: 68
Element was: 84
i is 84
#+end_example

Notice that before the =for= loop, =i=20= . Once the =for= loop begins, =i=
will be recreated and be asigned value =4= which is the first element of the
list. After the =for= loop, =i=84= .
*** the =range= function
[2018-05-19 Sat 20:00]

In ex32, there appears a builtin function =range=. =range= is used to generate a
sequence of integers, and its help doc is:
#+begin_example
Type:            type
String form:     <class 'range'>
Namespace:       Python builtin
Init definition: range(self, *args, **kwargs)
Docstring:
range(stop) -> range object
range(start, stop[, step]) -> range object

Return an object that produces a sequence of integers from start (inclusive)
to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.
start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.
These are exactly the valid indices for a list of 4 elements.
When step is given, it specifies the increment (or decrement).
#+end_example

Notice that:
    #+begin_src python
range(start,stop,step)
    #+end_src
will generate the sequence of integers including the =start= and excluding the
=stop= . This is different from Matlab, in which =start:step:stop= will include
both the =start= and the =stop= .
*** variable in the for loop and range
[2018-05-19 Sat 20:49]

Check the following code:
    #+begin_src python -n
def loopnumber(variable,step):
    numbers = []
    i = 2
    for i in range(i,variable,step):
        numbers.append(i)
    return numbers

variable = 9
step     = 2
print("The numbers: ")
for num in loopnumber(variable,step):
    print(num)
    #+end_src

Notice the =i= in the line 4, the first =i= will be created at the start of the
loop while the second =i= will take the value from line 3. So the contents of
=numbers= will be =[2,4,6,8]=
*** a project skeleton
[2018-05-25 Fri 21:38]

Because of the issue of python multi-version, it will be safe to
start your project with =virtualenv= . Using =virtualenv= , your python
environment is safe even if you install multiple python on your computer.
This section will help you create a skeleton directory which you can use to
start a new project up easily. The skeleton directory will have your project
layout, automated tests, modules, and install scripts. When a new project is to
be created, you just copy this directory ,rename it and everything is ready for
you to start coding.

As mentioned before, =virtualenv= will be needed. so install it:

#+begin_example
sudo pip3 install virtualenv
#+end_example

Sometimes, the pip will crash. If you want to reinstall your pip, goto the
[[https://pypi.org/project/pip/#files][website]] , download and extract the source, then install it using:

#+begin_example
sudo python3 setup.py install
#+end_example

During my installation of =virtualenv=, there is an error =Missing dependencies
for SOCKS support= . You need the following commands:

#+begin_example
unset all_proxy
unset ALL_PROXY
pip install pysocks
source .bashrc
#+end_example
and =pip= works again with socks proxy. want more please check [[https://stackoverflow.com/questions/40926018/pip-install-doesnt-work-invalidschema-missing-dependencies-for-socks-support/43135798][here]].

If =virtualenv= is ready, then you can create a python installation, which is
handy to manage versions of your package for different projects. The following
commands will create the virtual environment.

    #+begin_src shell -n
mkdir ~/.venvs
virtualenv ~/.venvs/lpthw
. ~/.venvs/lpthw/bin/activate
    #+end_src

then you will find the shell symbol changing from =$= to =(lpthw) $= . After
that you will find there is a =python= under =/lpthw/bin= . The final step is to
install =nose= , which is a testing framework we'll use.

#+begin_example
pip install nose
#+end_example

Notice that the =nose= will appear at directory =~/.venvs/lpthw/bin= . This let
you install different versions of python packages for different projects without
infecting the main system environment.


Note that when in shell you should have =(lpthw)= at the very beginning of the
line with =$=.

#+begin_example
. ~/.venvs/lpthw/bin/activate
#+end_example

will tell the shell that the virtual environment use python installed at
=~/.venvs/lpthw/bin/=

This project skeleton is useful when you want to create a module based on
certain vertion of python.
** DONE copy and deep copy in python               :python:
   CLOSED: [2018-06-01 Fri 21:16]
:PROPERTIES:
:EXPORT_FILE_NAME: copy-and-deep-copy-in-python
:EXPORT_DATE: <2018-05-28 Mon 19:50>
:EXPORT_DESCRIPTION: the frustraing "copy" in python. Every newbie of python from other language maybe frustrated by "copy" in python. In python, variable behaves like pointer. If you want to have "copy" like what other languages (say, C and java), you have to do extra work to make it.
:END:
:LOGBOOK:
- CLOSING NOTE [2018-06-01 Fri 21:16] \\
  done with draft
:END:

In the [[https://docs.scipy.org/doc/numpy/user/quickstart.html][tutorial of Numpy]], there a section called /Copies and Views/, as a newbie
of Python, I was shocked. In particular, some priori information of Matlab
aggravate the feeling even more. Let's take a look at what happened in Python
when I want to copy the value of one variable to another one.

*** No Copy at All

  Naturally, when I execute =b=a= in any language. =b= is expected to have the
  value of =a= , and if =a= and =b= are both array of =int= , then after =b=a= ,
  I execute =b[1]=b[1]+1= will make =b[1]= greater than =a[1]= by =1=. However,
  this is not the case in Python.

  For example:
  #+begin_example
  import numpy as np
  a = np.arange(12)
  b = a
  #+end_example

  The statement of =b is a= will return =True= which means that =b= and =a= are
  two names for the same array object. =b= and =a= behave like the pointer in C.
  if you execute =b[1] = 555= ,then =a[1]= will be =555= too.

  Also, if you use the =id()= function, =id(a)= and =id(b)= will return the same
  value. The =id()= function return the unique identifier of an object. If two
  objects have the same identifier, the two objects are actually one object.
*** view or Shallow Copy
    [2018-06-01 Fri 20:29]

    =view= is a good word for what shallow copy mean. For a large value, if you
    want to change part of it, you view the part you want to change.

    For example,
#+begin_example
import numpy as np
a = np.random.random((3,5))
#+end_example
If you just want to change the second and the third column of =a=, you view the
part you want change by slicing it:
#+begin_example
p = a[:,1:3]
p[:] = 10
#+end_example
Then the second and third column will be all =10= . =view= behaves like the
microscope. Only the part of viewed will be shared by the two objects.
*** Deep Copy
    [2018-06-01 Fri 20:35]

    What? deep copy? Yes, it's deep copy that implement the real copy as we
    expect.

    #+begin_example
    b = a.copy()
    #+end_example

    Then =b= is a complete copy of =a=. =b= and =a= will not share the same
    object id. This is what the copy we want.

    For example, if you have:
    #+begin_example
    import numpy as np
    a = np.arange(4)
    b = a.copy()
    b[0] = 4
    #+end_example

    you will have =b= equals =[4,1,2,3]= and =a= equals =[0,1,2,3]= . Now =b=
    and =a=


*** only happened in array

    Fortunately, the three version copy just happened on array type. when =b=
    and =a= are just integers or float numbers, ===  will implement the real
    copy.

    For example, when you have:
    #+begin_example
    a = 2
    b = a
    b += 2
    #+end_example
    then you get =b=4= and =a=2=

** DONE Python numpy tutorial                      :python:
   CLOSED: [2018-06-03 Sun 17:35]
   :PROPERTIES:
   :EXPORT_FILE_NAME: python-numpy-tutorial
   :EXPORT_DATE: <2018-06-02 Sat 09:26>
   :EXPORT_DESCRIPTION: As a replacement of Matlab (I miss Matlab for its clean and concise grammar), numpy is the core library for scientific computing in Python. It provides a high-performance multidimensional array object, and tools for working with these arrays.
   :END:
   :LOGBOOK:
   - CLOSING NOTE [2018-06-03 Sun 17:35] \\
     done with the numpy tutorial
   CLOCK: [2018-06-02 Sat 21:30]--[2018-06-02 Sat 22:17] =>  0:47
   CLOCK: [2018-06-02 Sat 18:46]--[2018-06-02 Sat 21:29] =>  2:43
   CLOCK: [2018-06-02 Sat 09:37]--[2018-06-02 Sat 12:45] =>  3:08
   CLOCK: [2018-06-02 Sat 09:27]--[2018-06-02 Sat 09:37] =>  0:10
   :END:
*** Python
    [2018-06-02 Sat 09:38]

    As a high-level dynamically typed multiparadigm programming language, python
    is attracts more and more attensions. Because of its strict indentation
    requirement, python code has some beauty in it.


    Using Emacs and IPython, I finished the [[http://cs231n.github.io/python-numpy-tutorial/][tutorial]] written by [[https://cs.stanford.edu/people/jcjohns/][Justin Johnson]] .
    The following sections share the same architecture as in the tutorial.
    However, for the sake of learning, I input all the code and add my
    understanding. Because I learn Matlab beforehand, some differencec between
    Matlab and Python are mentioned. During the learning, I use python 3.6
    instead of python 3.5 in the tutorial.
**** Basic data types
    [2018-06-02 Sat 12:03]

    Like most languages, Python has a number of basic types including integers,
    floats, booleans, and strings.
***** numbers
     [2018-06-02 Sat 12:04]

     Numbers include integer and float types and work as in other language.

     #+begin_src python
     x = 3
     print(type(x)) # Prints "<class 'int'>"
     print(x)       # Prints "3"
     print(x+1)     # Addition; prints "4"
     print(x-1)     # Subtraction; print "2"
     print(x*2)     # Multiplication; prints "6"
     print(x**2)    # Exponentiation; print "9"
     x += 1
     print(x)       # Print "4"
     x *= 2
     print(x)       # Print "8"
     y = 2.5
     print(type(y)) # Print "<class 'float'>"
     print(y, y+1, y*2, y**2) # Prints "2.5 3.5 5.0 6.25"
     #+end_src

     Python has =+==  , =*== , =-== , =/==  operators. However =a++= and =a--=
     are not supported in Python.


***** Booleans
      [2018-06-02 Sat 18:46]

      Different from Matlab, Python use =and= , =or= to implement Booleans
      logic. In Matlab, which was implemented using =&&= and =||= .

      #+begin_src python
      t = True
      f = False
      print(type(t)) # Prints "<class 'bool'>"
      print(t and f) # logical AND; prints "False"
      print(t or f)  # logical or; prints "True"
      print(not t)   # logical NOT; print "False"
      print(t != f)  # logical XOR; prints "True"
      #+end_src

      In matlab "not equal" was symbolized by =~== instead of =!== .
***** Strings
      [2018-06-02 Sat 19:28]

      I think Python support more on strings.

      #+begin_src python
      hello = 'hello' # String lterals can use single quotes
      world = "world" # double quotes; has the same effects as single ones
      print(hello)    # Prints hello
      print(len(hello)) #String length; prints "5"
      hw = hello + ' ' + world # String concatenation
      print(hw) # prints "hello world"
      hw12 = '%s %s %d' % (hello,world,12)
      print(hw12) # Prints "hello world 12"
      #+end_src

      In Python3.6, there is a handy sting called f-string. The last two lines
      code above can be written as:

      #+begin_src python
      print(f'{hello} {world} 12')
      #+end_src

      Quite a lot of methods are provided for strings:
      #+begin_src python
      s = "hello"
      print(s.capitalize())   # Capitalize a string; prints "Hello"
      print(s.upper()) # Print "HELLO"
      print(s.rjust(7)) # right-justify a string, padding with spaces;
      print(s.center(7)) # center a string, padding with space;
      print(s.replace('l','(ell)')) # replace all instances of one substring
      #with another
      #+end_src

      More methods can be found [[https://docs.python.org/3.5/library/stdtypes.html#string-methods][in the document]].
**** Containers
     [2018-06-02 Sat 19:51]

     There are four built-in container types: lists, dictionaries, sets and
     tuples.
***** lists
      [2018-06-02 Sat 19:57]

      A list is the Python equivalent of an array, but is resizeable and can
      contain element of different types.

      #+begin_src python
      xs = [3,1,2] # Create a list
      print(xs,xs[2]) # prints "[3,1,2] 2"
      print(xs[-1]) # print the last element; print "2"
      xs[2] = 'foo' # different  types
      print(xs) # print "[3,1,'foo']"
      xs.append('bar')
      print(xs) # print "[3,1,'foo','bar']"
      x = xs.pop()
      print(x,xs) # prints "bar [3,1,'foo']"
      #+end_src

      As usual, you can find all the gory details about lists [[https://docs.python.org/3.5/tutorial/datastructures.html#more-on-lists][in the document]].

      If you are impatient to access list elements one at a time, slicing is an
      excellent choice to access more than one elements in a list.

      #+begin_src python
      nums = list(range(5)) # range is a built-in function that create a list of integers
      print(nums) # print "[0,1,2,3,4]"
      print(nums[2:4]) # get a slice from index 2 to 4 (exclusive);print "[2,3]"
      print(nums[2:]) # prints "[2,3,]"
      print(nums[:2]) # get a slice from the start to index 2(exclusive). prints "[0,1]"
      print(nums[:]) # the whole list
      print(nums[:-1]) # slice indices can be negative; prints "[0,1,2,3]"
      nums[2:4] = [8,9]
      print(nums) # Prints "[0,1,8,9,4]"
      #+end_src

      You can also loop over the elements of a list like this:
      #+begin_src python
      animals = ['cat', 'dog','monkey']
      for animal in animals:
          print(animal)
      #+end_src

      If you want access to the index of each element within the body of a loop,
      use the built-in =enumerate= function

      #+begin_src python
      animals = ['cat','dog','monkey']
      for idx,animal in enumerate(animals):
          print('#%d: %s' % (idx + 1,animal))
      #+end_src


      Next, I want to show a point which does not exists in Matlab: list
      comprehensions. Consider the following code:
      #+begin_src python
      nums = [0,1,2,3,4]
      squares = []
      for x in nums:
          squares.append(x ** 2)
      print(squares)
      #+end_src

      Using the list comprehensions, we implement the above with extremely short
      code.

      #+begin_src python
      nums = [0,1,2,3,4]
      squares = [x ** 2 for x in nums]
      print(squares)
      #+end_src

      You do not have to define =square= before you use it. list comprehensions
      can also contain conditions:

      #+begin_src python
      nums = [0,1,2,3,4]
      even_squares = [x ** 2 for x in nums if x % 2 == 0]
      print(even_squares)
      #+end_src
***** Dictionaries
      [2018-06-02 Sat 20:58]

      The values in a dictionary are pairs of =(key,value)= . You can access the
      value through the key just like what you do when you look up a dictionary.

      Dictionary type use ={}= as the limiters.

      #+begin_src python
      d = {'cat':'cute','dot':'furry'} # Create a new dictionary with some data
      print(d['cat']) # Get an entry from a dictionary using the key 'cat'
      print('cat' in d) # Prints "True"; check if a dictionary has a given entry
      d['fish'] = 'wet' # set a new entry in a dictionary
      print(d['fish'])  # print "wet"
      print(d.get('monkey','N/A')) # get an element with a default; print "N/A"
      print(d.get('fish','N/A')) # Print "wet"
      del d['fish'] # remove an element from a dictionary
      print(d.get('fish','N/A')) # Print "N/A"
      #+end_src

      More methods for dictionary can be found [[https://docs.python.org/3.5/library/stdtypes.html#dict][in the document.]]

      Like in list, you can also loop in a dictionary. The different is that in
      a dictionary, you loop using the keys.

      #+begin_src python
      d = {'person':2, 'cat':4,'spider':8}
      for animal in d:
          legs = d[animal]
          print(f'a {animal} has  {legs} legs')
      #+end_src

      The output will be:
      #+begin_example
      a person has  2 legs
      a cat has  4 legs
      a spider has  8 legs
      #+end_example


      Also, there is dictionary comprehensions, which are similar to list
      comprehensions, but allow you to easily construct dictionaries.

      #+begin_src python
      nums = [0,1,2,3,4]
      even_num_to_square = {x: x**2 for x in nums if x % 2 == 0}
      print(even_num_to_square)
      #+end_src

      Notice that you can even print a dictionary directly using the =print=
      function.
***** Sets
      [2018-06-02 Sat 21:46]


      A set is a collection of distinct elements. Notice the world *distinct*. A
      set has the same meaning what a mathematician mean. In particular, in a
      set there are not two identical elements. Set use ={}= as the limiter the
      same as dictionary.

      #+begin_src python
      animals = {'cat','dog'}
      print('cat' in animals) # True
      print('fish' in animals) # False
      animals.add('fish') # add 'fish' in the set
      print('fish' in animals) # True
      print(len(animals)) # 3
      animals.add('cat') # add 'cat' second time, nothing happen
      print(len(animals)) # 3
      animals.remove('cat') # remove 'cat' from the set
      print(len(animals)) # 2
      #+end_src

      You can find more about set [[http://cs231n.github.io/python-numpy-tutorial/#python-sets][in the document]].

      You can also iterate over a set. Since sets are unordered, you cannot make
      assumptions about the order in which you visit the elements of the set.

      #+begin_src python
      animals = {'cat','dog','fish'}
      for idx,animal in enumerate(animals):
          print(f'# {idx} : {animal}')
      #+end_src

      And the output will be:
      #+begin_example
      # 0 : fish
      # 1 : cat
      # 2 : dog
      #+end_example

      Like lists and dictionarier, sets can be constructed by set
      comprehensions.
      #+begin_src python
      from math import sqrt
      nums = {int(sqrt(x)) for x in range(20)}
      print(nums)
      #+end_src

      The output will be:
      #+begin_example
      {0,1,2,3,4}
      #+end_example
***** Tuples
      [2018-06-03 Sun 11:26]

      Tuple is the fourth container in Python. A tuple is an immutable ordered
      list of values. A tuple is in many ways similiar to a list. One of the
      most important differences is that tuples can be used as keys in
      dictionaries and as elements of sets, while lists cannot. Let's take a
      look at a trivial example.

      A tuple is enclosed in parentheses. It is not possible to assign to the
      individual items of a tuple. However, it is possible to create tuples
      which contain mutable objects, such as lists.

      #+begin_src python
      d = {(x,x+1):x for x in range(10)} # create a dictionary
      t = (5,6) # create a tuple
      print(type(t)) # <class 'tuple'>
      print(d[t]) # 5
      print(d[(1,2)]) # 1
      #+end_src

      You can find more about tuples [[https://docs.python.org/3.5/tutorial/datastructures.html#tuples-and-sequences][in the document.]]
**** Functions
      [2018-06-03 Sun 11:37]

      Python function are defined using the =def= keyword. For example:
      #+begin_src python
      def fib(n):
          """Print a fibonacci series up to n"""
          a,b = 0,1
          while a < n:
              print(a,end = ' ')
              a,b = b,a+b
          print()
      #+end_src

      The keyword =def= introducs a function definition which must be followed
      by the function name and the parenthesized list of formal parameters. The
      statements that form the body of the function start at the next line, and
      must be indented.


      Sometimes, we want to define functions that have default arguments, like
      this:
      #+begin_src python
      def hello(name, loud=False):
          if loud:
              print(f'HELLO, {name.upper()}')
          else:
              print(f'Hello, {name}')
      #+end_src

      Notice that =loud= will be =False= by default. If you call the function
      =hello= with asignning any value to =loud=, it will be =False=.  Of
      course, you can call =hello= using =hello('Bob',True)= . You can also call
      =hello= using =hello('Bob',loud=True)= .

      You can find more about define a function [[https://docs.python.org/3.5/tutorial/controlflow.html#defining-functions][in the document.]]
*** Numpy
     [2018-06-03 Sun 11:53]

     As the core library of scientific computing in Python, Numpy make Python a
     replacement of Matlab even when there are quite a lot of differences
     between Numpy and Matlab. Because of open course, Numpy gets quite a lots
     of features to support scientific computation.
**** Arrays
    [2018-06-03 Sun 11:59]

    A numpy array is a grid of values. All the values share the same type. A
    numpy array can be indexed by a tuple of nonnegative integers. The number of
    dimensions is the rank of the array. The shape of an array is a tuple of
    integers giving the size of the array along each dimension.

    We can create a numpy arrays from nested Python lists, and access elements
    using square brackets.
    #+begin_src python
    import numpy as np
    a = np.array([1,2,3])
    print(type(a))
    print(a.shape)
    print(a[0],a[1],a[2])
    a[0] = 5
    print(a)

    b = np.array([[1,2,3],[4,5,6]])
    print(b.shape)
    print(b[0,0],b[0,1],b[1,0])
    print(b.ndim)
    #+end_src

    As in Matlab, numpy also provides many functions to create special arrays:
    #+begin_src python
    import numpy as np

    a = np.zeros((4,4))
    print(a)

    b = np.ones((2,2))
    print(b)

    c = np.full((2,2),9)
    print(c)

    d = np.eye(2)
    print(d)

    e = np.random.random((2,2))
    print(e)
    #+end_src

    Another two useful methods are =arange= and =linspace=
    #+begin_src python
    import numpy as np

    a = np.arange(10) #exclude 10
    print(a)

    b = np.linspace(1,4,6) #include 4
    print(b)
    #+end_src

    More methods can be found [[https://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation][in the document]].
**** Array indexing
     [2018-06-03 Sun 12:28]

     You can access the element of an array one by one or more than one at a
     time. I like slicing very much. Because it is an effective way to access
     more than one elements at a time.
***** slicing indexing
      [2018-06-03 Sun 16:23]
      #+begin_src python
      import numpy as np

      a = np.array([[1,2,3,4],
                    [5,6,7,8],
                    [9,10,11,12]])
      b = a[:2,1:3]
      print(b)
      c = a[::2,0::2]
      print(c)

      #+end_src
      The output will be:
      #+begin_example
     [[2 3]
      [6 7]]
     [[ 1  3]
      [ 9 11]]
      #+end_example

      Notice that:
      1. In python, index starts from zero instead of one. (In Matlab, index
         starts from one)
      2. the slicing has the form =start:stop:step= , which mean start from the
         =start= and stop at =stop= (exclusive) with step as =step=

      In Python, negative integer can also be used as index which provides
      flexibility for accessing the elements in an array.

      One important thing about slicing is that the origin one and the sliced
      result are closely related. please take a look at [[https://www.zcl.space/computer/copy-and-deep-copy-in-python/][this post]].

      Let's follow the above example.
      #+begin_src python
      b[0,0] = 99
      print(b)
      print(a)
      #+end_src

      And the output will be:
      #+begin_example
      [[99  3]
       [ 6  7]]

      [[ 1 99  3  4]
       [ 5  6  7  8]
       [ 9 10 11 12]]
      #+end_example

      Notice that the =99= appears at =b[0,0]= and =a[0,1]= . I did not set
      =a[0,1]= explicitly, but it was changed.

      When you index the numply arrays using slicing, the resulting array view
      will always be a subarray of the original way. If you change the subarray,
      the origin array will be changed too. This is pretty weird for engineer
      coming from Matlab.
***** integer array indexing
       [2018-06-03 Sun 16:23]

       Another way of indexing array is integer array indexing. For example:
       #+begin_src python
       import numpy as np
       a = np.array([[1,2],
                     [3,4],
                     [5,6]])

       print(a[[0,1,2],[0,1,0]])
       #+end_src

       Notice that integer array indexing does not have the effect of "view". You
       can change the new array resulting from integer array indexing without
       worry about changing the origin array.

       Another advantage of integer array indexing is that you can modify certain
       positions of an array at a time. For example:
       #+begin_src python
       import numpy as np

       a = np.array([[1,2,3],
                     [4,5,6],
                     [7,8,9],
                     [10,11,12]])

       print(a)

       #Create an array of indices
       b = np.array([0,2,0,1])
       # Select one element from each row of the array
       # using the indices in b

       print(a[np.arange(4),b])

       a[np.arange(4),b] += 10

       print(a)
       #+end_src

       Notice that only some positions of the array =a= are added 10. The
       positions are represented by =np.arange(4),b= . I think this is of high
       efficiency.
***** boolean array indexing
      [2018-06-03 Sun 16:23]

      Boolean array indexing is another method of indexing an array. In matlab,
      there is boolean array indexing too. According to my experience, boolean
      array indexing is used to pick up certain elements of an array satisfying
      cerntain conditions.

      #+begin_src python
      import numpy as np
      a = np.array([[1,2],
                    [3,4],
                    [5,6]])
      # bool_idx are positions where
      # the elements are greater than 2
      bool_idx = (a > 2)

      print(bool_idx)

      print(a[bool_idx])
      print(a[a>2])
      #+end_src

      The shape of =bool_idx= is the same as =a= . The value of =bool_idx= is
      =True= where =a>2= satisfies. The last line tells us that we can finish
      the finding of positions and picking up the elements in one concise
      statement.


      You can find more on indexing [[https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html][in the document.]]
**** Datatypes
      [2018-06-03 Sun 16:33]

      Every numpy array is a grid of elements of the same type. Numpy provides a
      large set of numeric datatypes that you can use to construct arrays. Numpy
      tries to guess a datatype when you create an array, but functions that
      construct arrays usually also include an optional argument to explicitly
      specify the datatype. For example:
      #+begin_src python
      import numpy as np
      x = np.array([1,2])
      print(x.dtype)

      x = np.array([1.0,2.0])
      print(x.dtype)

      x = np.array([1,2],dtype=np.int64)
      print(x.dtype)

      x = np.random.random((1,2))
      print(x.dtype)

      x = np.array([1+5j,2 + 4j])
      print(x.dtype)
      #+end_src
      The output is :
      #+begin_example
      int64
      float64
      int64
      float64
      complex128
      #+end_example

      Notice that for a complex number, numpy use the =complex128= to
      indicate the datetype.
**** Array math
     [2018-06-03 Sun 16:44]

     It is always more efficient to do algebra in vector mode so that the
     computation is expected to be finished in a parallel way. Because
     everything in python is object, the operators can be overloaded.

     #+begin_src python
     import numpy as np

     x = np.array([[1,2],[3,4]],dtype=np.float64)
     y = np.array([[5,6],[7,8]],dtype=np.float64)


     print(x+y)
     print(np.add(x,y))
     #+end_src

     One point that needs our attention is the matrix multiplication. There are
     two types of multiplication between matrices: one is elementwise
     multiplication and the other one is matrix multiplication. In Matlab, we
     use =*= to implement the matrix multiplication and =.*= to implement the
     elementwise multiplication. In Python, things are different. =*= is use to
     implement elementwise multiplication and =dot= is used to compute matrix
     multiplication.

     #+begin_src python
     import numpy as np

     x = np.array([[1,2],[3,4]])
     y = np.array([[5,6],[7,8]])

     v = np.array([9,10])
     w = np.array([11,12])

     # all the following 4 statements produce 219
     print(v.dot(w))
     print(w.dot(v))
     print(np.dot(v,w))
     print(np.dot(w,v))

     # matrix multiplication

     print(x.dot(y))
     print(np.dot(x,y))

     # AB != BA
     print(y.dot(x))
     print(np.dot(y,x))
     #+end_src

     Like in Matlab, we can sum up the matrix along one axis.

     #+begin_src python
     import numpy as np

     x = np.array([ [1,2],[3,4] ])

     # sum all the elements of x
     print(np.sum(x))

     # sum along the column
     print(np.sum(x,axis=0))
     # sum along the row
     print(np.sum(x,axis=1))
     #+end_src

     Changing the shape of an array is also one frequent operation. The most
     used operation is transposing a matrix.
     #+begin_src python
     import numpy as np

     x = np.array([[1,2],[3,4]])

     print(x)
     print(x.T)
     #+end_src

     If you want to reshape an array, =shape= is used.

     #+begin_src python
     import numpy as np

     a = np.arange(12)
     print(a)

     b = a.reshape((3,4))
     print(b)
     #+end_src
     The output will be:
     #+begin_example
     [ 0  1  2  3  4  5  6  7  8  9 10 11]

     [[ 0  1  2  3]
     [ 4  5  6  7]
     [ 8  9 10 11]]
     #+end_example

     Notice that =np.arange(n)= will exclude the =n=. and from shape =(12,)= to
     shape =(3,4)=, Python write the =(3,4)= row first. However, in Matlab, it
     is column first.
**** Broadcasting
     [2018-06-03 Sun 17:10]


     In Matlab, if you want to add two  matrices, they must have the same
     dimension, or an error will be throwed out.  However, in Python there is a
     mechanism called "Broadcasting" which allow you to work with arrays with
     different shapes.

     Suppose we want to add a constant vector to each row of a matrix. We would
     like this:
     #+begin_src python
     import numpy as np

     x = np.array([[1,2,3],
                   [4,5,6],
                   [7,8,9],
                   [10,11,12]])

     v = np.array([1,0,1])

     #create an empty matrix with the same shape as x
     y = np.empty_like(x)

     for i in range(4):
         y[i,:] = x[i,:] + v

     print(y)
     #+end_src

     The above code implement what we want. However, from the eye of Python, it
     is not concise. You have to iterate over =x= . Python allows you broadcast
     the =v= to each row of =x=

     #+begin_src python
     import numpy as np

     x = np.array([[1,2,3],
                   [4,5,6],
                   [7,8,9],
                   [10,11,12]])
     v = np.array([1,0,1])
     y = x + v
     print(y)
     #+end_src

     It is so easy. It works even =x= has shape =(4,3)= and =v= has shape =(3,)=
     due to broadcasting.

     Broadcasting two arrays together follows theses rules:
     1. if the arrays do not have the same shape, prepend the shape of the lower
        array with 1s until both shapes have the same length.
     2. The two arrays are said to be compatible in a dimension if they have the
        same size in the dimension, of if one of the arrays has size 1 in that
        dimension.
     3. The arrays can be broadcast together if they are compatible in all
        dimensions.
     4. After broadcasting, each array behaves as if it had shape equal to the
        elementwise maximum of shapes of the two input arrays.
     5. In any dimension where one array had size 1 and the other array had size
        greater than 1, the first array behaves as if it were copied along that
        dimension.

     Please check [[http://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc][this document]] and [[https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html][this document]] for more explainations.
     Functions that support broadcasting is called the universal function. You
     can find all the available universal function in [[https://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs][this document]].
*** summary
     [2018-06-03 Sun 17:33]

     This post summrize some important aspects of Numpy. However, it is far to
     be like the [[https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html][numpy refernence]]. You should check the numpy reference
     frequently when you are not sure what you are using.

* Reference

bibliography:~/zorg/research_library/zcl.bib
bibliographystyle:unsrt
